%%% My NixOS configuration

%% Author: Raghavendra Nyshadham <rn@raghnysh.com>
%%
%% I place this file in the public domain through the Creative Commons
%% CC0 1.0 Universal Public Domain Dedication, and waive all copyright
%% and related rights to the work.  See
%%
%% http://creativecommons.org/publicdomain/zero/1.0/
%%
%% for the CC0 dedication.

\documentclass{article}

\usepackage{configuration}

\addbibresource{configuration.bib}

\title{My NixOS configuration}

\hypersetup{pdftitle={My NixOS configuration}}

\hypersetup{pdfsubject={Computer programming}}

\newcommand{\cczero}{I place this document in the public domain
  through the Creative Commons CC0 1.0 Universal Public Domain
  Dedication, and waive all copyright and related rights to the work.
  See \url{http://creativecommons.org/publicdomain/zero/1.0/} for the
  CC0 dedication.}

\author{Raghavendra Nyshadham\thanks{\cczero} \\
  {\normalsize\nolinkurl{rn@raghnysh.com}}}

\hypersetup{pdfauthor={Raghavendra Nyshadham (rn@raghnysh.com)}}

\date{2023-11-21}

\begin{document}

\begin{titlingpage}
  \maketitle

  \begin{abstract}
    This document describes the configuration of the operating system
    of my computer, the Linux distribution NixOS.  I use the Noweb
    literate programming system to obtain from this document a NixOS
    configuration file and a PDF rendition of the document.  The
    current version of the document is available at
    \url{https://github.com/raghnysh/nixoscfg}.

    \ghtopics{nixos, system-configuration}
  \end{abstract}
\end{titlingpage}

\tableofcontents

\section{Introduction}
\label{sec:xikfhzau}
%\markboth{}{Inroduction}

This document describes the configuration of the operating system of
my computer, the Linux distribution NixOS.  I use the Noweb literate
programming system to obtain from this document a NixOS configuration
file and a PDF rendition of the document.  The current version of the
document is available at \url{https://github.com/raghnysh/nixoscfg}.

\subsection{Prerequisites}
\label{sec:prctvuey}

This document depends on a knowledge of the basics of the Nix package
manager \parencite{bib:q7nwwdbe} which is the basis of NixOS, the
Nixpkgs framework \parencite{bib:krparfs8} which provides the packages
and other software components of NixOS, and of course of the operating
system NixOS itself \parencite{bib:8n2stl3b}.  It also depends on a
knowledge of the Noweb literate programming system
\parencite{bib:199mna1w} in whose markup language it is written, and
whose tools are used to process it.  Apart from these, it of course
depends on a knowledge of the basic settings of some of the software
packages that are configured in it, such as Bash and Emacs, for which
the manuals of these packages are the obvious sources of information.

\subsection{System settings and user settings}
\label{sec:rf3avzmc}

The NixOS configuration consists of a single file
\filename{configuration.nix}, which is located in the directory
\filename{/etc/nixos/}.  This is the configuration file that Noweb
generates from this document.  The file consists entirely of settings
for various parameters.  There are broadly two kinds of settings:
system settings and user settings.  System settings are for parameters
that affect the entire system, whereas user settings are for
parameters that affect just the current user, that is, me.

The system settings are fully documented in the man page of
\filename{configuration.nix} \parencite{bib:5ndx9q4j}.  As for the
user settings, I use the \emph{Home Manager} tool for declaratively
configuring my user environment.  More specifically, I use the NixOS
module provided by Home Manager, which enables me to include the user
settings also in the system file \filename{configuration.nix}.  The
settings provided by Home Manager are documented in the man page of
\filename{home-configuration.nix} \parencite{bib:vxfvl1fo}.

Without the Home Manager NixOS module, the user settings would be
distributed over multiple files in my home directory, such as
\filename{.bashrc}, \filename{.inputrc}, and
\filename{.emacs.d/init.el}.  I find it inconvenient to spread the
configuration like this, and prefer to have all my settings in a
single file.  (It is even better that this single file
\filename{configuration.nix} contains the system settings also because
it means that I only have to keep track of this one file for the
entire configuration of the computer.  No more worries about backing
up varied configuration files scattered over the hard disk.)

So those then are the two components of my NixOS configuration: system
settings and user settings.  These two groups of settings are tied
together using some basic Nix language constructs in the file
\filename{configuration.nix} to form a valid Nix expression.  This Nix
expression fully specifies the configuration of my NixOS system.

\subsection{Overview of the document}
\label{sec:7ies7w0n}

In this paragraph and the next few, I will describe an outline of the
rest of this document.  In the next section, which is
\Cref{sec:plqdxsb9}, I will describe the system settings.  Each
subsection of that section describes the settings of a particular
subsystem of the computer, such as the sound subsystem, or the
graphical interface.  Some of these settings were specified by the
NixOS installer (by which I mean the NixOS installation program)
itself and left unchanged by me, while some are specified by me.
Whenever I use settings declared by the installer without any change,
I will indicate that fact in the appropriate subsection.

I will describe the user settings in \Cref{sec:6x3u5wbd}.  Each
subsection of that section is about the configuration of a particular
user program, except for the subsections on the configuration of
Emacs; my configuration of Emacs is long enough that it is convenient
to break it into multiple subsections.  Other important parts of this
section are those on the configuration of Bash, Readline, and
\TeX\ Live.

In \Cref{sec:89cb2h40}, I will describe how to combine the system
settings and the user settings to derive the Nix expression that
specifies the full NixOS configuration.  I will first specify the
import of the Home Manager NixOS module and other necessary modules.
I will then describe how to use the constructs provided by some of
these modules to incorporate the user settings into the general
configuration to obtain the final Nix expression.

In the last section, which is \Cref{sec:mhymr3fu}, I will say
something about the process of writing this document.  This is my
first stab at literate configuration, in fact at literate anything,
and I want to note to myself some of the difficulties that I ran into
during this process.  It may guide me in my future efforts in literate
programming.

At the end of the document is a bibliography of some of the references
that I have used, a list of the code chunks of the document, and
another of the identifiers described in the document.

\subsection{Colophon}
\label{sec:a06mny9n}

This document is written using the \LaTeX\ class \nwverb|article|,
with customisations that are contained in the \LaTeX\ file
\filename{configuration.sty} that accompanies the Noweb source of this
document.

As is common, the page layout is done with the \LaTeX\ package
\nwverb|geometry|, and the headers and footers of the pages are made
using the package \nwverb|fancyhdr|.  The page layout settings are
mostly copied from the file \filename{hott-ebook.tex} of the HoTT book
project (\url{https://github.com/HoTT/book}); I find the PDF ebook
product of that project very pleasant to read.

There are two levels of division in the document: \nwverb|section| and
\nwverb|subsection|.  The titles and numbers of these divisions, and
the page numbers, form the content of the headers and footers of the
pages.  I begin each section on a new page because I find that doing
so gives the best match between the header and footer of each page and
the content of that page.

Pages on which sections begin have no headers other than page numbers;
this is also true of pages belonging to sections without subsections
such as the sections containing the table of contents, the
bibliography, etc.  This is an idiosyncracy caused by the way I use
the \LaTeX\ page marking commands \nwverb|\markboth| and
\nwverb|\markright|, but I find that it distinguishes such pages
clearly from other pages.

The main font of the document is Palatino from the \LaTeX\ pacakge
\nwverb|newpxtext|, and the monospace font is Inconsolata from the
package \nwverb|inconsolata|.

The literate programming components of the document, such as code
chunks and cross-references to them, are provided by the \LaTeX\
package \nwverb|noweb|.  The NixOS configuration file is extracted
from the document using the program \nwverb|notangle|, and a \LaTeX\
version of the document is produced using the programs
\nwverb|noweave|; both these programs belong to the Noweb system.  The
PDF rendition of the document is made from the \LaTeX\ version of it
using the build system \nwverb|latexmk|.

\section{System settings}
\label{sec:plqdxsb9}

\lipsum[1-2]

\subsection{Base versions}
\label{sec:nfbc9c13}

I first specify the base versions of NixOS and Home Manager.  NixOS
and Home Manager will try to remain compatible with the respective
base versions whenever they are upgraded.  I installed Home Manager
for the NixOS 23.05 release, so I will use that number as the common
base version of both NiXOS and Home Manager.

\begin{codechunk}
\nextchunklabel{chk:v2y4tcc5}
<<Common base version>>=
23.05
@
\end{codechunk}

\begin{codechunk}
\nextchunklabel{chk:ab5rprt3}
<<System base version setting>>=
system.stateVersion = "<<Common base version>>";
@ %def system.stateVersion
\end{codechunk}

\begin{codechunk}
\nextchunklabel{chk:n2jcgc64}
<<Home Manager base version setting>>=
home.stateVersion = "<<Common base version>>";
@ %def home.stateVersion
\end{codechunk}

\subsection{Networking}
\label{sec:wtcs4nl2}

The networking setup is quite simple.  I just set the hostname of the
computer, and hand over the control of everything else to the
NetworkManager application \parencite{bib:abdahnqa}.

\begin{codechunk}
\nextchunklabel{chk:ldypnl10}
<<Network settings>>=
<<Hostname setting>>
<<Pass control to NetworkManager>>
@
\end{codechunk}

\begin{codechunk}
\nextchunklabel{chk:5f4lk1lm}
<<Hostname setting>>=
networking.hostName = "bastet";
@ %def networking.hostName
\end{codechunk}

\begin{codechunk}
\nextchunklabel{chk:3jf5xa81}
<<Pass control to NetworkManager>>=
networking.networkmanager.enable = true;
@ %def networking.networkmanager.enable
\end{codechunk}

The users who need to control the NetworkManager application must be
added to the appropriate user group:
\begin{codechunk}
\nextchunklabel{chk:oqyve0v3}
<<NetworkManager group>>=
networkmanager
@
\end{codechunk}

\subsection{Date and time}
\label{sec:jhrur9yx}

The date and time settings are specified by the time zone.
\begin{codechunk}
\nextchunklabel{chk:smjj65dp}
<<Time zone setting>>=
time.timeZone = "Asia/Kolkata";
@ %def time.timeZone
\end{codechunk}

\subsection{Locale settings}
\label{sec:3dmlfks5}

\firstterm{Locale} settings specify the language used on this system
for messages and such, and the preferences for linguistic aspects of
the user interface of the system such as the order of characters to be
used in sorting \parencite{bib:nhg983t7}.  These settings are a part
of the process of \firstterm{internationalisation} (which word is
abbreviated as \firstterm{i18n}), whose aim is to design software so
that it can be easily adapted to different cultural environments
\parencite{bib:kiy97d4i}.
\begin{codechunk}
\nextchunklabel{chk:2uu0q8ox}
<<Locale settings>>=
<<Base language setting>>
<<Sorting order setting>>
@
\end{codechunk}

The base language setting is used by applications as the default
specification of language when there is no other explicit instruction
as to what language should be used by the application for its user
interfaces.  I choose British English, the language and the variant of
that language that I am most comfortable with.
\begin{codechunk}
\nextchunklabel{chk:k2trmtxk}
<<Base language setting>>=
i18n.defaultLocale = "en_GB.UTF-8";
@ %def i18n.defaultLocale
\end{codechunk}

When a list of words is sorted (as in the output of the \nwverb|ls|
command), an order that is commonly used is one in which numbers
precede upper case letters, which in turn precede lower case letters.
This order is specified with the following locale setting:
\begin{codechunk}
\nextchunklabel{chk:9qh82y4i}
<<Sorting order setting>>=
i18n.extraLocaleSettings.LC_COLLATE = "C.UTF-8";
@ %def i18n.extraLocaleSettings.LC_COLLATE
\end{codechunk}

\subsection{Unfree packages}
\label{sec:deod83sq}

The \filename{configuration.nix} file that was created when I first
installed NixOS allowed unfree packages to be installed on the
computer.  I don't know why this was so, but it seems best to leave it
as such.
\begin{codechunk}
\nextchunklabel{chk:gcdlllyw}
<<Unfree packages setting>>=
nixpkgs.config.allowUnfree = true;
@ %def nixpkgs.config.allowUnfree
\end{codechunk}

\subsection{Suspension on lid closure}
\label{sec:9a4uflmp}

I would like to suspend the computer when the laptop lid is closed, as
was the case in my previous Linux Mint setup.  The default
configuration of the system ensures that the computer is suspended
when the laptop lid is closed and no external monitor is attached to
the laptop.  It takes a bit of configuration to ensure that the
computer is suspended when the laptop lid is closed and an external
monitor is attached to the laptop.

Suspension is controlled by a system service called
\firstterm{systemd-logind} \parencite{bib:x9v7o65s}.  The settings of
this service are specified in a file called \filename{logind.conf}
\parencite{bib:p9pioc5i}.  I specify that the \nwverb|systemd-logind|
service should suspend the computer when the laptop lid is closed and
an external monitor is attached to the laptop.
\begin{codechunk}
\nextchunklabel{chk:uhhhefz3}
<<Logind setting for lid closure>>=
services.logind.lidSwitchDocked = "suspend";
@ %def services.logind.lidSwitchDocked
\end{codechunk}

This does not work because the system-wide power manager
\firstterm{UPower} also tries to control what happens when the laptop
lid is closed \parencite{bib:872u2noz}.  It seems to inhibit the
suspension of the computer by \nwverb|systemd-logind| when the lid is
closed in the presence of an external monitor.  I therefore specify
that \nwverb|UPower| should ignore the laptop lid.
\begin{codechunk}
\nextchunklabel{chk:vj3wncpe}
<<UPower setting for laptop lid>>=
services.upower.ignoreLid = true;
@ %def services.upower.ignoreLid
\end{codechunk}
I learnt of the role of \nwverb|UPower| in this issue from an article
by \textcite{bib:d08j7tjg}.

I now combine the \nwverb|systemd-logind| and \nwverb|UPower|
settings.
\begin{codechunk}
\nextchunklabel{chk:i0bdh589}
<<Lid closure settings>>=
<<Logind setting for lid closure>>
<<UPower setting for laptop lid>>
@
\end{codechunk}

\subsection{Bootloader}
\label{sec:7vkm2mz8}

The \firstterm{bootloader} is a program that is responsible for
booting the computer \parencite{bib:rezy6nz0}.  The following settings
are taken unchanged from the original file
\filename{configuration.nix} that was created by the NixOS installer.
I did not learn more about them because I did not need to modify them.

\begin{codechunk}
\nextchunklabel{chk:ci46g78f}
<<Bootloader settings>>=
boot.loader.systemd-boot.enable = true;
boot.loader.efi.canTouchEfiVariables = true;
@ %def boot.loader.systemd-boot.enable
@ %def boot.loader.efi.canTouchEfiVariables
\end{codechunk}

\subsection{Graphical environment}
\label{sec:ba88v5eg}

For the graphical user interface of the NixOS operating system, I have
left unchanged the original settings created by the NixOS installer.
I did not explore these settings because I did not need to modify
them.

\begin{codechunk}
\nextchunklabel{chk:vvehkrpj}
<<Graphical environment settings>>=
services.xserver.enable = true;
services.xserver.displayManager.gdm.enable = true;
services.xserver.desktopManager.gnome.enable = true;
services.xserver.layout = "us";
services.xserver.xkbVariant = "";
@ %def services.xserver.enable
@ %def services.xserver.displayManager.gdm.enable
@ %def services.xserver.desktopManager.gnome.enable
@ %def services.xserver.layout
@ %def services.xserver.xkbVariant
\end{codechunk}

\subsection{Printing}
\label{sec:9z18mjmr}

I have kept the configuration of the printing software as it was
created by the NixOS installer.

\begin{codechunk}
\nextchunklabel{chk:aquk20pl}
<<Setting for printing>>=
services.printing.enable = true;
@ %def services.printing.enable
\end{codechunk}

\subsection{Sound}
\label{sec:5vk5vbq4}

The settings for the sound input and output systems are kept unchanged
from the NixOS installation.  I do not know what these settings mean,
and did not bother to learn about them because I did not need to
modify them.

\begin{codechunk}
\nextchunklabel{chk:8j9bit25}
<<Settings for sound>>=
sound.enable = true;
hardware.pulseaudio.enable = false;
security.rtkit.enable = true;
services.pipewire.enable = true;
services.pipewire.alsa.enable = true;
services.pipewire.alsa.support32Bit = true;
services.pipewire.pulse.enable = true;
@ %def sound.enable
@ %def hardware.pulseaudio.enable
@ %def security.rtkit.enable
@ %def services.pipewire.enable
@ %def services.pipewire.alsa.enable
@ %def services.pipewire.alsa.support32Bit
@ %def services.pipewire.pulse.enable
\end{codechunk}

\subsection{Copy of the configuration}
\label{sec:pai37tz6}

This setting specifies that the file
\filename{/etc/nixos/configuration.nix} should be copied to the Nix
store, and that a symbolic link to that copy should be created from
\filename{/run/current-system/configuration.nix}.  I turn this setting
on because I find it useful, when making a sequence of configuration
changes that have not yet been committed to Git, to look at the
configuration that was current when the last \nwverb|nixos-rebuild|
command was issued.
\begin{codechunk}
\nextchunklabel{chk:sgsxqbsc}
<<Copy of configuration>>=
system.copySystemConfiguration = true;
@ %def system.copySystemConfiguration
\end{codechunk}

\section{User settings}
\label{sec:6x3u5wbd}

\lipsum[1-2]

\subsection{My user profile}
\label{sec:qopaextu}

My username on this computer is \nwverb|raghnysh|, which is an
abbreviation of my name
\begin{codechunk}
\nextchunklabel{chk:inddl4ui}
<<My name>>=
Raghavendra Nyshadham
@
\end{codechunk}

My user profile is configured through the attribute set
\begin{verbatim}
users.users.raghnysh
\end{verbatim}

The first attribute I add to my user profile set is my name:
\begin{codechunk}
\nextchunklabel{chk:4n5aawhc}
<<My user profile settings>>=
users.users.raghnysh.description = "<<My name>>";
@ %def users.users.raghnysh.description
\end{codechunk}

I am a ``real'' user as opposed to a ``system'' user such as the user
\nwverb|cups| which manages printing services on this computer.
\begin{codechunk}
\nextchunklabel{chk:ynaxhugb}
<<My user profile settings>>=
users.users.raghnysh.isNormalUser = true;
@ %def users.users.raghnysh.isNormalUser
\end{codechunk}

I have to be a member of the user group \nwverb|wheel| to carry out
administrative tasks on the computer using the \nwverb|sudo| command.
\begin{codechunk}
\nextchunklabel{chk:p7mkklj7}
<<My user groups>>=
wheel
@
\end{codechunk}
I also have to be able to control the NetworkManager application to
make changes to the network configuration whenever needed, so I have
to be a member of the appropriate user group.
\begin{codechunk}
\nextchunklabel{chk:zmd46nq3}
<<My user groups>>=
<<NetworkManager group>>
@
\end{codechunk}
I add the list of the user groups which contain me to my user profile
set.
\begin{codechunk}
\nextchunklabel{chk:2ddciyul}
<<My user profile settings>>=
users.users.raghnysh.extraGroups = [
  <<My user groups>>
];
@ %def users.users.raghnysh.extraGroups
\end{codechunk}
That completes the declaration of my user profile.

\subsection{Custom keybindings}
\label{sec:gnyboe66}

I want keyboard shortcuts for a few frequently used commands.  The
shortcuts are configured through the \firstterm{dconf} system
\parencite{bib:2jswiol0}.  The dconf settings consist of certain keys
and their values.  Related keys are gathered into \emph{groups}.  In
NixOS a dconf setting is specified by an attribute of the form
\begin{verbatim}
dconf.settings."<group>".key = value;
\end{verbatim}

Thus, keyboard shortcuts are configured by the attribute
\begin{codechunk}
\nextchunklabel{chk:ywnwef13}
<<Keyboard shortcuts setting>>=
dconf.settings."<<kbs-group>>".<<kbs-key>> = <<kbs-value>>;
@
\end{codechunk}
The dconf group under which keyboard shortcuts are configured looks
like a relative path:
\begin{codechunk}
\nextchunklabel{chk:q91ldjml}
<<kbs-group>>=
org/gnome/settings-daemon/plugins/media-keys
@
\end{codechunk}
The dconf key associated with keyboard shortcuts is
\begin{codechunk}
\nextchunklabel{chk:c4puclwq}
<<kbs-key>>=
custom-keybindings
@
\end{codechunk}
The value of this key is a list of the form
\begin{verbatim}
["/<shortcut1-group/" "/shortcut2-group/" ...]
\end{verbatim}
The first member \nwverb|shortcut1-group| of this list is a dconf
group that configures the keyboard shortcut \nwverb|shortcut1|; the
other members configure other keyboard shortcuts.  I am configuring
only one keyboard shortcut \textemdash{} whose effect will be to
suspend the computer \textemdash{} so I have only one member in this
list:
\begin{codechunk}
\nextchunklabel{chk:rldqngod}
<<kbs-value>>=
["/<<suspend-group>>/"]
@
\end{codechunk}
where
\begin{codechunk}
\nextchunklabel{chk:ta5kmggo}
<<suspend-group>>=
<<kbs-group>>/<<kbs-key>>/suspend
@
\end{codechunk}

The \nwverb|suspend| group has three keys: \nwverb|name|,
\nwverb|binding|, and \nwverb|command|.
\begin{codechunk}
\nextchunklabel{chk:bu6iiooz}
<<Keyboard shortcut for suspending the computer>>=
dconf.settings.<<suspend-group>>.name = "Suspend the computer";
dconf.settings.<<suspend-group>>.binding = "Pause";
dconf.settings.<<suspend-group>>.command = "systemctl suspend";
@
\end{codechunk}

\section{Consolidation}
\label{sec:89cb2h40}

\lipsum[1-2]

\subsection{The Home Manager NixOS module}
\label{sec:6afjlq40}

I embed the Home Manager configuration into the system settings file
\filename{configuration.nix} as a NixOS module instead of maintaining
a separate configuration file for Home Manager.  This module provides
the \nwverb|home-manager.*| attributes used in the following sections.
In particular, it provides the attribute
\begin{codechunk}
\nextchunklabel{chk:snqjctlt}
<<Home Manager user attribute name>>=
home-manager.users.raghnysh
@ %def home-manager.users.raghnysh
\end{codechunk}
which is an attribute set containing my configuration of Home Manager.

The Home Manager version I am using is the common base version that I
had specified in \Cref{sec:nfbc9c13}.
\begin{codechunk}
\nextchunklabel{chk:g17cix3p}
<<Home Manager version>>=
<<Common base version>>
@
\end{codechunk}
The \nwverb|nixos-rebuild| program will download this version of the
Home Manager distribution as a tarball.  It can check the integrity of
the tarball by comparing its SHA-256 hash with the following:
\begin{codechunk}
\nextchunklabel{chk:7gmacbr9}
<<Home Manager tarball hash>>=
0rwzab51hnr6cmm1w5zmfh29gbkg6byv8jnr7frcv5kd6m8kna41
@
\end{codechunk}

The filename of the Home Manager tarball is
\begin{codechunk}
\nextchunklabel{chk:x8khoj7y}
<<Home Manager tarball name>>=
release-<<Home Manager version>>.tar.gz
@
\end{codechunk}
and its base URL is
\begin{codechunk}
\nextchunklabel{chk:krjsvds4}
<<Home Manager tarball base URL>>=
https://github.com/nix-community/home-manager/archive
@
\end{codechunk}
The full URL of the tarball is
\begin{codechunk}
\nextchunklabel{chk:50p0prn4}
<<Home Manager tarball URL>>=
<<Home Manager tarball base URL>>/<<Home Manager tarball name>>
@
\end{codechunk}

The \nwverb|nixos-rebuild| programm will download the tarball and
extract it to a directory whose pathname is given by the
\nwverb|fetchTarball| function:
\begin{codechunk}
\nextchunklabel{chk:t5941yr3}
<<Home Manager path>>=
builtins.fetchTarball {
  url = "<<Home Manager tarball URL>>";
  sha256 = "<<Home Manager tarball hash>>";
}
@
\end{codechunk}
The Home Manager NixOS module is contained in a subdirectory of the
above directory:
\begin{codechunk}
\nextchunklabel{chk:e9swsiot}
<<Home Manager NixOS module path>>=
"${<<Home Manager path>>}/nixos"
@
\end{codechunk}

\subsection{General settings of Home Manager}
\label{sec:jpohtaim}

The settings for Nixpkgs \parencite{bib:krparfs8}, the software
packaging system of NixOS, can be specified either through the system
configuration that applies to all users, or through the Home Manager
configuration that applies only to specific users.  According to the
Home Manager manual \parencite{bib:p9hb002v}, the former method
``saves an extra Nixpkgs evaluation, adds consistency, and removes the
dependency on NIX\_PATH'', so I use it.
\begin{codechunk}
\nextchunklabel{chk:spfjj8sn}
<<General settings of Home Manager>>=
home-manager.useGlobalPkgs = true;
@ %def home-manager.useGlobalPkgs
\end{codechunk}

Home Manager by default installs Nixpkgs packages in a directory under
my home directory.  Alternatively, there is an option which makes Home
Manager install these packages in a user-specific directory under
\filename{/etc/}.  The Home Manager manual \parencite{bib:p9hb002v}
says that this ``option may become the default value in the future'',
so I choose this option.
\begin{codechunk}
\nextchunklabel{chk:nb5ml4v1}
<<General settings of Home Manager>>=
home-manager.useUserPackages = true;
@ %def home-manager.useUserPackages
\end{codechunk}

\subsection{Import of modules}
\label{sec:wk15aj6o}

\begin{codechunk}
\nextchunklabel{chk:qbq68axo}
<<Imports setting>>=
imports = [
  ./hardware-configuration.nix
  <<Home Manager NixOS module path>>
];
@
\end{codechunk}

\subsection{Assembling the configuration file}
\label{sec:p9imo12d}

\begin{codechunk}
\nextchunklabel{chk:o7ygwvzn}
<<configuration-noweb.nix>>=
{
  <<Imports setting>>
  <<System base version setting>>
  <<Copy of configuration>>
  <<Bootloader settings>>
  <<Network settings>>
  <<Time zone setting>>
  <<Locale settings>>
  <<Unfree packages setting>>
  <<Graphical environment settings>>
  <<Setting for printing>>
  <<Settings for sound>>
  <<Lid closure settings>>
  <<My user profile settings>>
  <<General settings of Home Manager>>
  <<Home Manager user attribute name>> = { pkgs, ... }: {
    <<Home Manager base version setting>>
    <<Keyboard shortcuts setting>>
  };
}
@
\end{codechunk}

\section{Coda}
\label{sec:mhymr3fu}

\lipsum[1-2]

\subsection{The difficulties of literate configuration}
\label{sec:gwzq6dz9}

\lipsum[3-4]

\subsection{Literate programming in interpreted languages}
\label{sec:lg4xtyfn}

\lipsum[5-6]

\section{Failure}
\label{sec:wzm7cwrh}

This document is not getting anywhere.  My progress is painfully slow,
both in writing the documentation and in extending the configuration
to cover more settings.  I have failed in creating a literate
configuration of NixOS on my computer, so I am abandoning the idea of
a literate configuration in this case.  I will try to write about the
reasons for this failure.

My problem was that to bring the computer to a state where I could use
Emacs, Noweb, and \TeX\ Live to develop the literate configuration, I
already needed to have a fair amount of configuration in the computer.
I had to create this working configuration in the usual way, that is,
by hand (as opposed to tangling it out of a Noweb document) and
non-literally.  I then had the task of using Noweb to describe the
working configuration as if it was being done afresh.  I had to do
literate programming after the programming part \textemdash\ the
configuration \textemdash\ has been done, which is not really literate
programming.  So I had a mass of configuration (about 600 lines) that
I had to describe in the Noweb file, which was quite daunting and
tiring.

Another thing was that I could not tangle the code from the Noweb file
to the actual target, the file \filename{configuration.nix}, because
any mistakes in the configuration chunks of the Noweb file would then
result in a broken computer system.  So I had to tangle the code from
the Noweb file to a different file,
\filename{configuration-noweb.nix}.

While writing the Noweb file, I had to add some more configuration
items to \filename{configuration.nix}, and those too needed to be
documented.  I was writing documentation for a configuration file that
changed every now and then.  It made an already difficult task even
more so.  As a result, I hesitated to add new configuration to
\filename{configuration.nix}, so there are large parts of my computer
system that are not yet configured.

\bibsection

\nowebchunkssection

\nowebindexsection

\end{document}

%%% End of file
